# HTTP 1.1 / 2.0 / 3.0
작성자: 장수현

## HTTP 1.1
### Pipelining
기본적으로 HTTP 요청은 순차적이기 때문에 요청에 대한 응답을 받고 나서야 새로운 요청을 보낸다. 하지만 HTTP 1.1 에서는 응답을 기다리지 않고 요청을 연속적으로 보내는 기능이 추가되었다. 하나의 connection에서 한 번에 순차적인 여러 요청을 보내고 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄인다.

<br>

### 한계
#### 1. HOL(Head Of Line) Blocking – 특정 응답의 지연
요청의 순서와 응답의 순서는 동기화 되어야 하므로 특정 요청을 처리하는데 많은 시간이 걸린다면 그 뒤의 다른 요청을 처리하는데 지연이 발생한다.

#### 2. 무거운 Header 구조 (특히 Cookie)
매 요청시마다 중복된 header를 보내 뿐만 아니라 cookie 정보도 매 요청마다 헤더에 포함되어 전송된다. 즉, 불필요한 데이터를 주고 받는데 네트워크 자원이 소비되는 문제가 발생한다.

#### 3. RTT(Round Trip Time) 증가
TCP 상에서 동작하는 HTTP 특성상 3-way handshake 가 반복적으로 일어나 불필요한 RTT 증가와 네트워크 지연을 일으켜 성능을 저하시킨다.

<br>

## HTTP 2.0
### Multiplexed Streams
HTTP 1.1의 HTTP Pipelining 의 개선안으로 하나의 Connection으로 동시에 여러 개의 메세지를 주고 받을 수 있다. 응답은 요청 순서에 상관없이 Stream 으로 받기 때문에 HOL Blocking이 발생하지 않는다.

### Stream Prioritization
요청한 리소스간 우선순위를 설정하여 의존성 있는 파일의 수신이 늦어지는 경우 브라우저 렌더링이 늦어지는 문제 해결한다.

### Server Push
서버는 클라이언트가 요청하지 않은 리소스 보내줄 수 있다. http 2.0 에서는 server push  기법을 이용해서 요청하지 않은 리소스를 push 하여 클라이언트의 추가적인 요청을 최소화하여 성능 향상을 시킨다.

<br>

### 한계
그러나 HOL Blocking의 완전한 문제 해결은 되지 않았다. TCP 프로토콜을 사용하는 이상, TCP 패킷이 네트워크 경로에서 손실되면 스트림에 공백이 생겨 그 다음에 오는 바이트들도 재전송으로 인해 전달이 되지 않아 지연이 생긴다. 특히 HTTP 2.0은 여러개의 스트림을 하나의 TCP Connection으로 처리해 더 크게 영향을 받는다.

<br>

## HTTP 3.0
### UDP
가장 큰 특징은 TCP가 아닌 UDP를 사용한다는 것이다. HTTP 3.0은 QUIC라는 프로토콜 위에서 돌아가는 HTTP인데, QUIC는 Quick UDP Internet Connection의 약자로 UDP를 사용하는 프로토콜이다. QUIC는 TCP hand shake 과정을 최적화하는 것에 초점을 맞추어 설계되었다. UDP는 데이터그램 방식을 사용하는 프로토콜이기에 각각의 패킷 간 순서가 존재하지 않는 독립적인 패킷이다.UDP는 TCP에 비해 헤더가 많이 비어있기에, 커스터마이징할 수 있는 여지가 많고 이를 이용해 개발자가 구현을 어떻게 하느냐에 따라서 신뢰성을 확보할 수 있다.